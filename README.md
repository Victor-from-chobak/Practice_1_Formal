# Описание алгоритма
Заведем стек, в которой будем класть списки длины k, описывающие : какая минимальная длина может быть у слова, задаваемым регулярным выражением, длины которого дает остаток i по модолю k. Алгоритм устроен так :
* Идем по входной строке слева направо 
* Если встречаем букву или символ 1, то кладем в стек, соответствующий список 
* Если встречаем знак суммы, то применяем эту операцию к двум верхним массивам, то есть резуьтат в позиции i - это минимум из соответствующих значений в слагаемых, получаем асимптотику O(k)
* Если встречаем знак конкатенации, то применяем эту операцию к двум верхним массивам, то есть результат в позиции i - это минимум из множества всех возможных полученных произведений, точнее, если m + j = i(mod k), причем в множетелях значения на позициях m и j, соответственно определены, то их произведение следует рассмотреть, как возможный ответ в позиции i. Получим асимптотику операции O(k^2)
* Если встречаем знак замыкания, то применяем ее к верхнему символу на стеке, причем, заметив, что замыкание а это 1 + a + aa + aaa + ..., то эту операцию можно выполнить используя сумму и умножение, причем из теории групп, свойтств кольца Zk,    следует, что достаточно рассмотреть только сумму первых (k + 1) слагаемых. Тогда эта операция займет O(k^3).
* Отметим, что оценка затраченной памяти O(k|RE|), где RE - данное регулярное выражение
* К деталям реализации добавим, что при отсутсвии возможного остатка r у регулярного выражения, положим значение INF_VALUE = 2 10^9
* Ответ будет в единственном списке на вершине стека в позиции l 

# Реализация 
Для алгоритма реализован класс _polish_notation_stack_ с методом _find_minimum_len_equals_l_mod_k_, который возвращает ответ на задачу, при корректной польской нотации, в ином случае будет брошено исключение _run_time_error_(при ручном тестировании будет выведено ERROR). У стека есть метод top, аналогичный методу std::stack, так же соответствующие методы для суммы, конкатенации и замыкания, имеющие названия _make_sum_operation_, _make_concatenate_operation_, _make_closure_operation_. 

# Тестирование 
Чтобы собрать проект нужно:
* mkdir build
* cd build 
* cmake . .
* make 

После этого, можно тестировать вручную с помощью _./task_solver_, ввод-вывод из стандартного потока. Так же реализовано автоматическое тестирование с помощью _gtest_, проверить можно с помощью _./run_tests_. Есть _unit_ тесты для отдельных методов, суммы, конкатенации, замыкания, добавления вектора, символа и других, так же сами тесты алгоритма. _Code-coverage_ замерялся с помощью _gcov_, проверить можно с помощью _make gcov_, после чего будут отображены результаты тестирования.
